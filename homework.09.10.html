<script>
// 함수 
// 함수를 사용하는 이유 
// 1. 여러줄에 걸쳐 실행되던 동일한 작업을, 함수 호출 한줄로 동일한 결과를 만들어 낼 수 있다. DRY: (Don't repeat yourself)
// 2.반복됐던 만큼 코드양이 줄어 가독성을 높일 수 있다.

// 함수 문법 
// 1. 기본 구조 

// 함수 선언부
const 함수명 = function(인자1, 인자2 ...){
  실행문;
  ...
  return 반환값;
};
// 함수 호출부
const 반환받는 상수 = 함수명(인수1, 인수2 ...);

// 예제
const func1 = function(parameter1, parameter2){
  const sum1 = parameter1 + parameter2;
  return sum1l
};
const returned1 = func1('argument1', 'argument2');
// func1(1,2); 호출해보기 
//-> 3이 나온다.
// 함수 안에 return이 없다면 returned1의 값은?
// -> undefined
// argument2를 넘기지 않는다면 sum1의 값은?
// -> 'argumentundefined'
// argument1, argument2  둘다 넘기지 않는다면 sum1 의 값은?
// -> NaN
// parameter2를 지운다면 sum1의 값은?
// -> 에러가 나타난다.
//- parameter1은 함수 내부적으로 let parameter1 = 인수1 이렇게 작동 한다.
//`parameter1`, `parameter2` 둘다 지운다면 `sum1`의 값은?
//-> 에러가 나타난다.
//문제: console.log('함수 호출');이라는 실행문을 가진 함수를 상수 f1에 넣고, 해당 함수 호출 시키기
const f1 = function(){
  console.log('함수호출');
}
f1();

// 2. 인수에 자료형 데어터 넘기기
const scriptConst2 = 'a';
const func2 = function(parameter1) {
    const compare1 = scriptConst2 === parameter1;
    parameter1 = 'b';
    const compare2 = scriptConst2 === parameter1;
};
func2(scriptConst2);
// compare2는 참일까, 거짓일까?
// -> 거짓

// 인수에 배열 넘기기 
const scriptConst3 = [];
const func3 = function(parameter1) {
    const compare1 = scriptConst3 === parameter1;
    parameter1.push('a');
    scriptConst3.push('b');
    const compare2 = scriptConst3 === parameter1;
};
func3(scriptConst3);

compare1 -> true
compare2 -> true

// 빈 배열을 넣은 것이다. 
// 앞서 본 자료형이 아닌 객체(object), 배열, 함수는 같은 메모리 주소를 같기 때문에 
// 주소만 같다면 true, 아니라면 flase

//`compare2`는 `참`일까, `거짓`일까?
//-> true 
//빈 배열 같이 scriptConst3 과 parameter1 에 넣은 것이다. 결국 다른 값으로 push 를 해도 메모리 주소는 같다.

// 인수에 함수 넘기기
const scriptConst4 = function() {};
const func4 = function(parameter1) {
    const compare1 = scriptConst4 === parameter1;
    parameter1 = function() {};
    const compare2 = scriptConst4 === parameter1;
};
func4(scriptConst4);

// compare1 -> true
// compare2 -> false 

// compare2는 참일까, 거짓일까?
// -> false 

// 익명 함수를 인수로 넘기기
- func4(scriptConst4);

func4(function() {
  console.log('익명함수 호출');
});

//문제: `인수`로 넘긴 `익명 함수`를, `인자`로 호출 시키기
// `parameter1();
// 인수로 함수를 넘기고, 인자로 호출시키는 함수를 `콜백 함수`(Callback function)라 한다.`

//콜백 함수 = 함수를 변수 또는 다른 함수의 변수처럼 사용할 수 있다. 함수를 콜백함수로 사용할 경우, 함수의 이름만 넘겨주면 된다. ex) callback, finishFunc처럼 () 를 붙일 필요가 없단는 것이다.

//라이브러리: 특정 함수들의 모음 (Moment.js, Lodash)

// 함수 실습 (회원 CRUD만들기)
// 1.create 
const members =[];
const membersCreate = function(member){
  members.push(memeber);
  return members;
};
// 2. read
const membersRead = function(){
  return members;
};
// 3. update
const membersUpdate = function(){
  members[index] = member;
  return members;
};
// 4. delete
const membersDelete = function() {
  members.splice(index,1);
  return members;
};

// 오브젝트 
// 오브젝트를 사용하는 이유
// - 효율적인 관리를 위해 여러 변수를 한곳에 묶어서 사용한다.
// 배열과 오브젝트의 차이점
// - 배열은 숫자(index)로 요소에 접근하고, 오브젝트는 문자(key)로 요소에 접근한다.

// 오브젝트 문법 
// 1. 기본 구조 
const 오브젝트명 = {
  키1: 값1,
  키2: 값2
};
// 에제
const object1 = {};
const object2 = {
  key1: '값1', // 문자열
  key2: [1, 2, 3], // 배열
  key3: function() {
    // console.log(this.key1);
    return this;// 함수
  },
  key4: {
    k1: 'v1',
    k2: 'v2'// 오브젝트 안에 또 오브젝트를 넣을 수 있음 
  }
};

// 오브젝트 create 
object1.key1 = 1;
object2.key2 = '2';
object3['key3'] = '삼';
// 오브젝트 read
const o1 = object1.key1;
const o2 = object1['key2'];
const o3 = object1.key3;
// 오브젝트 update
object1['key1']=[];
Object1.key2=function() {};
Object1.key3 = {
  k1: 'v1',
  k2: 'v2'
};
// 오브젝트 delete 
delete object1.key1;
delete object1.key2;
delete object1['key3'];

// object2.key2 배열의 length 구하기 (. 연산자, 대괄호 연산자 사용)
//-> object2.key2.length
// object2.key3 함수 호출 시키기 (. 연산자, 대괄호 연산자 사용)
//-> object2.key3();
// this 연산자의 개념 설명, // console.log(this.key1); 주석을 푼다면
// — this 는 object2의 부모라고 생각하면 된다.
// 그래서 object2 == this 라고 보면 된다. 
// 주석을 풀게 되면 답은 '값' 이나오게 된다.
// object2.key4 오브젝트의 k1키 삭제 하기 (. 연산자, 대괄호 연산자 사용)
// =delete object2.key4.k1
// 키이름에 대한 규칙
//`영문, 숫자, _, $`를 자유롭게 조합해서 쓸 수 있다.
// 숫자를 앞으로 사용 불가 (1a, 2b, ...)

// 오브젝트의 for in문 
for (const c1 in object2) {
  const value1 = object2[c1];
  console.log(c1);
  console.log(value1);
  console.log(object2.c1);
}
//— for문은 반복문이기 때문에 console.log 끝까지 돌게 된다.

// 1. c1 이 key1값을 가지게 된다.
// 2. value1에 "값1" 을 가지게 된다.
// 3. console.log (c1); 값으로 "key1"을 가지게 된다.
// 4. console.log(value1); 값으로 "값1"을 가지게 된다.
// 5. console.log(object2,c1); 값으로 undefined값을 가지게 된다. *이유는 object2에는 c1 변수명이 없기 때문이다.

// — 이 과정을 key4까지 돌게 된다.


// **Object.keys 메소드 확인**

`const array2 = Object.keys(object2);
array2.length;`

// — keys를 주로 사용해서 length를 확인 할 수 있다. 

// =  아래 값으로 확인하게 된다.

array(4)

// 0 : "key1"
// 1 : "key2"
// 2: "key3"
// 3: "key4"
// length : 4

// 오브젝트 CRUD
// Create
membersCreate({
  name: '홍길동',
  age: 20
});

// Read
membersRead();

// Update
membersUpdate(0, {
  name: '김유신',
  age: 30
});

// Delete
membersDelete(0);

//**try catch문(제어문 > 예외처리문)**

//**try catch문을 사용하는 이유?**
//1. 에러가 발생할 경우 처리를 위해 사용한다
//2. try문 밖에서 에러가 발생할 경우 프로그램 진행이 멈추지만, try문 안에서 발생할 경우 프로그램이 계속 진행 된다.

//실행문에서 에러가 뜸 → 그럼 catch 에서 에러가 발생했기 때문에 catch 실행문이 실행 됨 → 그리고 계속해서 이어지게 끔 해주는 역할을 try catch가 해준다. (보통 에러가 떠서 그다음으로 못넘어감 )

// 기본구조 
try {
  실행문;
  ...
} catch(에러객체) {
  // try block에서 에러가 발생할 경우 실행
  실행문;
  ...

// 예제
try {
  t1;
  console.log('진행 가능1?');
} catch(error) {
  console.warn(error);
// 경고 차원에서 노랑색으로 뜸.
  console.error(error);
// 에러 차원에서 빨간색으로 뜸.
}
console.log('진행 가능2?')
</script>